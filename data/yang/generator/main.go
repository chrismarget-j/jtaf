package main

import (
	"crypto/sha256"
	"fmt"
	"io/fs"
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
)

const (
	yangConstPrefix   = "YANG"
	yangModPathAppend = "data/yang"
	regexPkgName      = "^[a-z]+$"
	regexPkgPath      = `^module ([^ ]+)$`
	warning           = "// this code generated by data/yang/generator/main.go - DO NOT EDIT"

	goSuffix   = ".go"
	yangSuffix = ".yang"

	topFileName        = "files_generated.go"
	goYangFileTemplate = "package %s\n\n%s\n\nconst %s=`%s`"
	goTopFileTemplate  = "package yang\n\n%s%s\n\nfunc init() {%s}\n"
)

var (
	dir          string
	pathToConst  map[string]string
	pkgNameRegex *regexp.Regexp
)

// wdf is the fs.WalkDirFunc called by filepath.WalkDir
func wdf(path string, d fs.DirEntry, err error) error {
	if err != nil {
		return fmt.Errorf("WalkDir encountered an error at path %q, entry %q - %w", path, d.Name(), err)
	}

	ok, err := validateFilePath(path)
	if err != nil {
		return fmt.Errorf("while validating file path %q - %w", path, err)
	}
	if !ok {
		return nil
	}

	relativePath := strings.TrimPrefix(path, dir+string(os.PathSeparator))
	relativePathSplit := splitDirs(relativePath)
	pkgName := relativePathSplit[0]

	constName, err := generateGoFile(path)
	if err != nil {
		return fmt.Errorf("while generating go file from %q - %w", path, err)
	}

	pathToConst[relativePath] = fmt.Sprintf("%s.%s", pkgName, constName)

	return nil
}

// validateFilePath inspects the filename and returns an indicator of whether the file should be processed
func validateFilePath(fileName string) (bool, error) {
	if !strings.HasSuffix(fileName, yangSuffix) {
		return false, nil
	}

	relativePath := strings.TrimPrefix(fileName, dir+string(os.PathSeparator))

	relativePathSplit := splitDirs(relativePath)
	if len(relativePathSplit) != 2 {
		log.Printf("ignoring yang file %q because it's not nested correctly within %q", relativePath, dir)
		return false, nil
	}

	pkgPath := relativePathSplit[0]
	if !pkgNameRegex.MatchString(pkgPath) {
		log.Printf("ignoring yang file %q because %q doesn't comply with go package naming requirements", relativePath, pkgPath)
		return false, nil
	}

	return true, nil
}

func constantFromFilename(fn string) (string, error) {
	h := sha256.New()
	_, err := h.Write([]byte(fn))
	if err != nil {
		return "", fmt.Errorf("while writing to hash generator - %w", err)
	}

	return fmt.Sprintf("%s%x", yangConstPrefix, h.Sum(nil)), nil
}

// generateGoFile ge
func generateGoFile(yangFileName string) (string, error) {
	goFileName := strings.Replace(yangFileName, yangSuffix, goSuffix, -1)
	goPkgName := path.Base(path.Dir(yangFileName))

	constName, err := constantFromFilename(yangFileName)
	if err != nil {
		return "", fmt.Errorf("while calculating yang constant name from %q - %w", yangFileName, err)
	}

	yangPayload, err := os.ReadFile(yangFileName)
	if err != nil {
		return "", fmt.Errorf("while reading yang payload from %q - %w", yangFileName, err)
	}

	goFilePayload := fmt.Sprintf(goYangFileTemplate, goPkgName, warning, constName, string(yangPayload))

	err = os.WriteFile(goFileName, []byte(goFilePayload), 0o644)
	if err != nil {
		return "", fmt.Errorf("while writing go file %q - %w", goFileName, err)
	}

	_ = goFileName
	_ = yangPayload

	return constName, nil
}

func main() {
	var err error

	dir, err = os.Getwd()
	if err != nil {
		log.Fatal(fmt.Errorf("while determining cwd - %w", err))
	}

	pkgNameRegex = regexp.MustCompile(regexPkgName)

	pathToConst = make(map[string]string)

	err = filepath.WalkDir(dir, wdf)
	if err != nil {
		log.Fatal(fmt.Errorf("while walking data directory %q - %w", dir, err))
	}

	err = genTopFile(pathToConst)
	if err != nil {
		log.Fatal(fmt.Errorf("while generating top file - %w", err))
	}
}

func genTopFile(pToC map[string]string) error {
	importBasePath, err := dataYangModulePath()
	if err != nil {
		return fmt.Errorf("while finding root go module - %w", err)
	}

	imports := make(map[string]struct{})
	initPayload := new(strings.Builder)
	var i int
	for p, c := range pToC {
		if i == 0 {
			initPayload.WriteString("\n")
		}
		imports[path.Join(importBasePath, path.Dir(p))] = struct{}{}
		initPayload.WriteString(fmt.Sprintf("\tFiles[\"%s\"] = %s\n", p, c))
		i++
	}

	importPayload := strings.Builder{}
	switch len(imports) {
	case 0:
		// nothing
	case 1:
		for k := range imports {
			importPayload.WriteString(fmt.Sprintf("import \"%s\"\n\n", k))
		}
	default:
		importPayload.WriteString("import (\n")
		for k := range imports {
			importPayload.WriteString(fmt.Sprintf("    \"%s\"\n", k))
		}
		importPayload.WriteString(")\n\n")
	}

	topFilePayload := fmt.Sprintf(goTopFileTemplate, importPayload.String(), warning, initPayload)

	err = os.WriteFile(topFileName, []byte(topFilePayload), 0o644)
	if err != nil {
		return fmt.Errorf("while writing %q - %w", topFileName, err)
	}

	return nil
}

func dataYangModulePath() (string, error) {
	extraPathComponents := splitDirs(yangModPathAppend)

	cwd, err := os.Getwd()
	if err != nil {
		return "", fmt.Errorf("while getting cwd - %w", err)
	}

	goModDir := cwd
	for range len(extraPathComponents) {
		goModDir = path.Dir(goModDir)
	}
	goModFile := path.Clean(path.Join(goModDir, "go.mod"))

	goModData, err := os.ReadFile(goModFile)
	if err != nil {
		return "", fmt.Errorf("while reading go mod file %q - %w", goModFile, err)
	}

	goModRegex := regexp.MustCompile(regexPkgPath)

	var mPath string
	for _, line := range strings.Split(string(goModData), "\n") {
		s := goModRegex.FindStringSubmatch(line)
		if len(s) != 2 {
			continue
		}
		mPath = s[1]
		break
	}
	if mPath == "" {
		return "", fmt.Errorf("failed to find module path in %q", goModFile)
	}

	pathComponents := make([]string, len(extraPathComponents)+1)
	pathComponents[0] = mPath
	for i, epc := range extraPathComponents {
		pathComponents[i+1] = epc
	}

	return path.Join(pathComponents...), nil
}

func splitDirs(path string) []string {
	parent, child := filepath.Split(path)
	if child == "" {
		return []string{strings.TrimSuffix(parent, string(filepath.Separator))}
	}
	return append(splitDirs(parent), child)
}
